# 《成语小秀才》核心玩法解析与源码

这个曾经在2020-2021年微信上火到炸裂的游戏，真的是日入斗金，也带火了一批同质化的游戏，我也蹭到一些流量，小赚了一笔。现在回过头来跟大家聊聊这个游戏的实现。游戏最核心还是成语棋盘的布局，有了棋盘的地图配置，应该是不难实现。首先看下成语小秀才的核心界面：



## 关卡渲染

以一个例子来看，以下数据结构用来渲染关卡，你也可以自定义成其他的，只要你方便实现游戏逻辑就行。

```json
{
        "word": ["山", "人", "穷", "高", "山", "流", "水", "人", "尽", "海"],
        "idiom": ["高山流水", "人山人海", "山穷水尽"],
        "posx": [4, 4, 6, 3, 6, 5, 6, 4, 6, 4],
        "posy": [2, 3, 3, 4, 4, 4, 4, 5, 5, 6],
        "answer": [4, 6, 9],
        "id": 1,
}
```

* idiom：存储成语列表用。有一个特点就是，两两之间一定有一个汉字是相同的，不然就没法接龙。

* word：汉字放在这数组里面，汉字是去重（去掉交集的那个）之后的总数。

* posx，posy：每个汉字所在的坐标位置，记录网格信息。

* answer：也就是本题目填空的答案，索引是对应word中的汉字：山、水、海。

初始化10\*10的网格（格子大小假设是50\*50），遍历word数组，创建block（事先定义一个预制体，后面讲）实例，获取对应汉字的posx，posy位置，设置实际渲染位置。如果遇到了answer中的索引，将当前格子的答案属性设置为answer的汉字，实际先不渲染出来，保持为空。那么就可以渲染得到以下内容：

![](<images/localhost_7456_(iPhone SE).png>)



## 成语关卡地图

成语地图是一个难点，就是生成上面的那段JSON。一般为了更好的运营维护，地图数据尽可能的放在后台，这样可以动态下发给玩家。这样一来，为了方便生成地图，需要制作一个成语地图生成器，按照前面说的格式输出JSON描述。

假如现在有一个网格10\*10，已知有三个成语：\["高山流水", "人山人海", "山穷水尽"]。高山流水从网格左上角开始摆放，高的坐标是【0,0】。那么可以将上面的三个成语布局成如下的样子

得到以下配置：

```javascript
{
        "word": ["山", "人", "穷", "高", "山", "流", "水", "人", "尽", "海"],
        "idiom": ["高山流水", "人山人海", "山穷水尽"],
        "posx": [1, 1, 3, 0, 3, 2, 3, 1, 3, 1], 
        "posy": [-2, -1, -1, 0, 0, 0, 0, 1, 1, 2], // 位置有负的
        "answer": [4, 6, 9],
        "id": 1,
}
```

但为了居中更加美观，需要调整一下位置，让文字尽量居中摆放，如下图

```javascript
{
        "word": ["山", "人", "穷", "高", "山", "流", "水", "人", "尽", "海"],
        "idiom": ["高山流水", "人山人海", "山穷水尽"],
        "posx": [4, 4, 6, 3, 6, 5, 6, 4, 6, 4],
        "posy": [2, 3, 3, 4, 4, 4, 4, 5, 5, 6],
        "answer": [4, 6, 9],
        "id": 1,
}
```

成语库github上有很多，可以随便找个词库量很大的，比如：https://github.com/pwxcoo/chinese-xinhua， 假设一个关卡需要三个成语，那么遍历整个成语数据可以组合出一个关卡，但是有些可能会出现位置占用的情况，需要做一些额外的位置判断，如果位置已经被占用，则跳过找下一个。另外一个就是边界判断，如果边界溢出了，也不符合要求。边界计算就是比如垂直方向posy数组中的最大值减去最小值大于总数量，同理水平方向也是如此。关卡这块主要是偏数值策划，保证关卡难度是逐级递增的，让用户感受到游戏目标的挑战性。

## 答题逻辑

整个核心玩法区域分为题目区和答案区

答案区的方块可点击，点击后隐藏，填充到题目区的选中方块。

题目区的格子有以下几种状态

* 固定汉字态，初始化有值，不能改也不能点击

* 选中态，有且只有一个

* 空格态，等待填充区

* 已答态，已经答过，还没有校验是否正确。如果还没校验，还可以被点击撤回，放回到答案区；如果校验正确则变为固定汉字态，不能响应交互。

为了简化处理，答案区和题目区的方块格子都有用同一个预制体，因为他们的逻辑非常接近，无非就是状态的切换。

各种状态如下图所示：

### 找空格

游戏开始需要找到一个空格，然后选中，答题之后找下一个空格选中，因此第一个算法就是找空格选中。

* 游戏开始没有选中的空格，在目前的空格中随机选中一个就行。

* 如果当前已经有选中的格子，当汉字被填入，获取横向和纵向的关联汉字格子。判断填字之后是否还有剩余，如果存在空格，则按照坐标顺序从左到右、从上到下选中下一个。直到所有的格子都填满，则查询下一个成语的空格。

获取成语关联汉字是关键。如图所示，红色的是当前选中的方块，分别需要查找水平和垂直方向的方块。查找方式就是遍历当前行和列的方块，条件是满足连续四个方块，并且当前选中的方块X或者Y坐标在连续四个方块内。可以参考如下代码：

```javascript
// 找连续的4个方块
var consecutiveCount = 0;
for (var i = 0; i < 9; i++) {
    var checkConsecutive = (function (n) {
        if (horizontalBlocks.filter(function (block) {
            return block.posIndex.x == n;
        }).length != 0) {
            consecutiveCount++;
        } else {
            consecutiveCount = 0;
        }
        if (consecutiveCount == 4 && block.posIndex.x >= n - 3 && block.posIndex.x <= n) {
            return {
                value: [
                    this.getBlock(n - 3, block.posIndex.y),
                    this.getBlock(n - 2, block.posIndex.y),
                    this.getBlock(n - 1, block.posIndex.y),
                    this.getBlock(n, block.posIndex.y)
                ]
            };
        }
    }).bind(this);
    var sequence = checkConsecutive(i);
    if (typeof sequence === 'object') {
        return sequence.value;
    }
}
```

如果关联的格子已经填满，这个时候需要判断答案是否正确，正确的话将格子状态固化，否则标红抖动提示答错。

所有全部填完，如果正确则完成关卡，顺利过关。

